// {
// 	"Basic C++ Structure": {
// 		"prefix": "cpp",
// 		"body": [
// 			"#include<bits/stdc++.h>",
// 			"using namespace std;",
// 			"#define ll long long int",
// 			"int main(){",
// 			"  ios_base::sync_with_stdio(false);cin.tie(NULL);",
// 			"  ll T;",
// 			"  cin>>T;",
// 			"  while(T--){",
// 			"    $1",
// 			"  }",
// 			"  return 0;",
// 			"}"
// 		],
// 		"description": "Basic C++ Program"
// 	}
// }


{
	"Basic C++ Structure": {
		"prefix": "cpp",
		"body": [
			"#include<bits/stdc++.h>",
			"using namespace std;",
			"#define ll long long int",
			"int main(){",
			"  ios_base::sync_with_stdio(false);cin.tie(NULL);",
			"  ll T;",
			"  cin>>T;",
			"  while(T--){",
			"    $1",
			"  }",
			"  return 0;",
			"}"
		],
		"description": "Basic C++ Program"
	},
	"MERGE SORT": {
		"prefix": "merge_sort",
		"body": [
			"#include<bits/stdc++.h>",
			"using namespace std;",
			"",
			"void merge(int arr[], int start, int mid, int end){",
			"  int left_arr_size, right_arr_size;",
			"",
			"  left_arr_size=mid-start+1;",
			"  right_arr_size=end-mid;",
			"",
			"  int left_arr[left_arr_size], right_arr[right_arr_size];",
			"",
			"  for(int i=0;i<left_arr_size;i++)",
			"    left_arr[i]=arr[start+i];",
			"",
			"  for(int i=0;i<right_arr_size;i++)",
			"    right_arr[i]=arr[mid+1+i];",
			"  ",
			"  int i,j,k;",
			"  i=j=0;",
			"  k=start;",
			"",
			"  // OPTIMAL MERGE PATTERN",
			"  while(i<left_arr_size && j<right_arr_size){",
			"    if(left_arr[i]<=right_arr[j]){",
			"      arr[k]=left_arr[i];",
			"      i++;",
			"    }else{",
			"      arr[k]=right_arr[j];",
			"      j++;",
			"    }",
			"    k++;",
			"  }",
			"",
			"  // FOR REMAING ITEM",
			"  while(i<left_arr_size){",
			"    arr[k]=left_arr[i];",
			"    i++;",
			"    k++;",
			"  }",
			"  while(j<right_arr_size){",
			"    arr[k]=right_arr[j];",
			"    j++;",
			"    k++;",
			"  }",
			"}",
			"",
			"void merge_sort(int arr[], int start, int end){",
			"    if(start>=end)return;",
			"",
			"    int mid=start+(end-start)/2;",
			"",
			"    merge_sort(arr, start, mid);",
			"    merge_sort(arr, mid+1, end);",
			"",
			"    merge(arr, start, mid, end);",
			"}",
			"",
			"int main(){",
			"  int number_of_item, start, end;",
			"",
			"  cout<<\"Enter Size of The Array: \";",
			"  cin>>number_of_item;",
			"",
			"  int arr[number_of_item];",
			"  cout<<\"Enter The Elements of The Array: \";",
			"  for(int i=0;i<number_of_item;i++)cin>>arr[i];",
			"",
			"  cout<<\"Enter The Begining And Ending Index: \";",
			"  cin>>start>>end;",
			"",
			"  merge_sort(arr, start, end);",
			"",
			"  cout<<endl<<\"Sorted Array:\";",
			"  for(int i=0;i<number_of_item;i++)cout<<\" \"<<arr[i];",
			"  ",
			"  return 0;",
			"}"
		],
		"description": ""
	},
	"BELLMAN FORD": {
		"prefix": "bellman_ford",
		"body": [
			"#include<bits/stdc++.h>",
			"using namespace std;",
			"",
			"int partition(int arr[], int low, int high){",
			"  int pivot, index;",
			"  pivot=arr[high];",
			"  index=low-1;",
			"",
			"  for(int j=low;j<high;j++)",
			"    if(arr[j]<=pivot){",
			"      index++;",
			"      swap(arr[index], arr[j]);",
			"    }",
			"  swap(arr[index+1], arr[high]);",
			"  return index+1;",
			"}",
			"",
			"void quick_sort(int arr[], int low, int high){",
			"  if(low<high){",
			"    int pivot_index;",
			"    pivot_index=partition(arr, low, high);",
			"    quick_sort(arr, low, pivot_index-1);",
			"    quick_sort(arr, pivot_index+1, high);",
			"  }",
			"}",
			"int main(){",
			"  int number_of_item, start, end;",
			"",
			"  cout<<\"Enter Size of The Array: \";",
			"  cin>>number_of_item;",
			"",
			"  int arr[number_of_item];",
			"  cout<<\"Enter The Elements of The Array: \";",
			"  for(int i=0;i<number_of_item;i++)cin>>arr[i];",
			"",
			"  cout<<\"Enter The Begining And Ending Index: \";",
			"  cin>>start>>end;",
			"",
			"  quick_sort(arr, start, end);",
			"",
			"  cout<<endl<<\"Sorted Array:\";",
			"  for(int i=0;i<number_of_item;i++)cout<<\" \"<<arr[i];",
			"  ",
			"  return 0;",
			"}"
		],
		"description": ""
	},
	"0 1 KNAPSACK": {
		"prefix": "0_1_knapsack",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"void zero_one_knapsack(vector<pair<int, int>> pairs, int knapsack_size){",
			"  // MEMOIZATION ARRAY",
			"  int arr[pairs.size()+1][knapsack_size+1];",
			"",
			"  // FILLING THE MEMOIZATOIN ARRAY WITH BOTTOM UP APPROACH",
			"  for(int i=0;i<=pairs.size();i++){",
			"    for(int j=0;j<=knapsack_size;j++){",
			"      if(i==0 || j==0)arr[i][j]=0;",
			"      else if(pairs[i-1].second<=j){",
			"        arr[i][j]=max(arr[i-1][j],pairs[i-1].first+arr[i-1][j-pairs[i-1].second]);",
			"      }else{",
			"        arr[i][j]=arr[i-1][j];",
			"      }",
			"    }",
			"  }",
			"",
			"  // GETTING SELECTED ITEM",
			"  int i,j;",
			"  i=pairs.size()-1;",
			"  j=knapsack_size;",
			"  vector<bool> selected;",
			"  while(i>0 && j>0){",
			"    if(arr[i][j]!=arr[i-1][j]){",
			"      selected.push_back(true);",
			"      j-=pairs[i].first;",
			"      if(j==0)selected.push_back(false);",
			"    }else{",
			"      selected.push_back(false);",
			"    }",
			"    i--;",
			"  }",
			"  reverse(selected.begin(), selected.end());",
			"",
			"  cout<<endl;",
			"",
			"  // DISPLAYING THE MEMOIZATION ARRAY",
			"  cout<<\"Memoization Table:\"<<endl;",
			"  for(int i=0;i<=pairs.size();i++){",
			"    for(int j=0;j<=knapsack_size;j++)cout<<arr[i][j]<<\" \";",
			"    cout<<endl;",
			"  }",
			"",
			"  cout<<endl;",
			"",
			"  // DISPLAYING SELECTED ITEM",
			"  cout<<\"Selected Item:\";",
			"  for(auto j: selected){",
			"    cout<<\" \"<<j;",
			"  }",
			"",
			"  cout<<endl;",
			"",
			"  // DISPLAYING SELECTED ITEM PAIR WISE",
			"  cout<<\"Selected Pairs:\"<<endl;",
			"  i=0;",
			"  for(auto j: selected){",
			"    if(j==1){",
			"      cout<<pairs[i].first<<\" \"<<pairs[i].second<<endl;;",
			"    }",
			"    i++;",
			"  }",
			"}",
			"",
			"int main(){",
			"  int knapsack_size, number_of_item, profit, weight;",
			"  vector<pair<int, int>> pairs;",
			"",
			"  cout<<\"Enter Number Of Item: \";",
			"  cin>>number_of_item;",
			"",
			"  for(int i=0;i<number_of_item;i++){",
			"    cout<<\"Enter \"<<i+1<<\"th Item Profit and Weight: \";",
			"    cin>>profit>>weight;",
			"    pairs.push_back(make_pair(profit, weight));",
			"  }",
			"",
			"  cout<<\"Enter Knapsack Size: \";",
			"  cin>>knapsack_size;",
			"",
			"",
			"  zero_one_knapsack(pairs, knapsack_size);",
			"",
			"  return 0;",
			"}"
		],
		"description": ""
	},
	"LCS": {
		"prefix": "lcs",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"pair<string, int> lcs_memoization(string str1, string str2){",
			"",
			"  // LENGTH OF EACH STRING",
			"  int m,n;",
			"  m=str1.length();",
			"  n=str2.length();",
			"  ",
			"  // MEMOIZATION ARRAY",
			"  int arr[m+1][n+1];",
			"",
			"  // INITIALIZING THE ARRAY WITH ZEROS",
			"  for(int i=0;i<=m;i++)",
			"    for(int j=0;j<=n;j++)",
			"      arr[i][j]=0;",
			"",
			"  // FILLING THE MEMOIZATOIN ARRAY WITH BOTTOM UP APPROACH AND GETTING THE LCS",
			"  string lcs_string;",
			"  for(int i=1;i<=m;i++)",
			"    for(int j=1;j<=n;j++)",
			"      if(str1[i-1]==str2[j-1]){",
			"        lcs_string.push_back(str1[i-1]);",
			"        arr[i][j]=arr[i-1][j-1]+1;",
			"      }else{",
			"        arr[i][j]=max(arr[i-1][j], arr[i][j-1]);",
			"      }",
			"",
			"  // DISPLAYING THE MEMOIZATION ARRAY",
			"  cout<<\"Memoization Table:\"<<endl;",
			"  for(int i=0;i<=m;i++){",
			"    for(int j=0;j<=n;j++)cout<<arr[i][j]<<\" \";",
			"    cout<<endl;",
			"  }",
			"",
			"  // LCS AND LENGTH OF LCS",
			"  return make_pair(lcs_string, arr[m][n]);",
			"}",
			"",
			"int lcs_recursive(string str1, string str2, int m, int n, string lcs_string){",
			"  if(m==0 || n==0)return 0;",
			"  else if(str1[m-1]==str2[n-1]){",
			"    lcs_string+=str1[m-1];",
			"    return 1+lcs_recursive(str1, str2, m-1, n-1, lcs_string);",
			"  }",
			"  else return max(lcs_recursive(str1, str2, m-1, n, lcs_string), lcs_recursive(str1, str2, m, n-1, lcs_string));",
			"}",
			"",
			"int main(){",
			"  string str1,str2;",
			"  cout<<\"Enter Your First String: \";",
			"  cin>>str1;",
			"  cout<<\"Enter Your Second String: \";",
			"  cin>>str2;",
			"  cout<<endl;",
			"",
			"  pair<string, int> response = lcs_memoization(str1, str2);",
			"  cout<<\"Length of LCS Using Memoization Method: \"<<response.first<<endl;",
			"  cout<<\"LCS using Memoization Method :\"<<response.second<<endl;",
			"",
			"  cout<<endl;",
			"",
			"  string lcs_string=\"\";",
			"  cout<<\"Length of LCS Using Recursion: \"<<lcs_recursive(str1, str2, str1.length(), str2.length(), lcs_string)<<endl;",
			"  cout<<\"LCS using Recursion: \"<<lcs_string<<endl;",
			"  return 0;",
			"}"
		],
		"description": ""
	},
	"ALL PAIR": {
		"prefix": "all_pair",
		"body": [
			"// FLOYD WARSHAL ALGORITHM",
			"#include<bits/stdc++.h>",
			"using namespace std;",
			"",
			"void floyd_warshal(vector<vector<int>> graph){",
			"",
			"  // CALCULATING SHORTEST PATH",
			"  for(int k=0;k<graph.size();k++)",
			"    for(int i=0;i<graph.size();i++)",
			"      for(int j=0;j<graph.size();j++)",
			"        if(graph[i][j]>(graph[i][k]+graph[k][j]) && graph[i][k]!=INT_MAX && graph[k][j]!=INT_MAX)",
			"          graph[i][j]=graph[i][k]+graph[k][j];",
			"",
			"  // DISPLAYING ALL PAIR SHORTEST PATH",
			"  cout<<endl<<\"All Pairs Shortest Path:\"<<endl;",
			"  for(int i=0;i<graph.size();i++){",
			"    for(int j=0;j<graph.size();j++)",
			"      (graph[i][j]==INT_MAX)?cout<<\"INT_MAX \":cout<<graph[i][j]<<\" \";",
			"    cout<<endl;",
			"  }",
			"}",
			"",
			"int main(){",
			"  int vertices, edges;",
			"",
			"  cout<<\"Enter Number of Vertices and Edges: \";",
			"  cin>>vertices>>edges;",
			"",
			"  // INITIALIZING LOOP NODE 0 AND OTHER INFINITY",
			"  vector<vector<int>> graph;",
			"  for(int i=0;i<vertices;i++){",
			"    vector<int> v;",
			"    for(int j=0;j<vertices;j++)v.push_back(INT_MAX);",
			"",
			"    graph.push_back(v);",
			"    graph[i][i]=0;",
			"  }",
			"",
			"  // GETTING INPUT",
			"  for(int i=0;i<edges;i++){",
			"    int from, to, weight;",
			"    cout<<\"Enter \"<<i+1<<\"th Edges and Their Weights: \";",
			"    cin>>from>>to>>weight;",
			"    graph[from-1][to-1]=weight;",
			"  }",
			"",
			"  // DISPLAYING GIVEN GRAPH",
			"  cout<<endl<<\"Given Graph:\"<<endl;",
			"  for(int i=0;i<vertices;i++){",
			"    for(int j=0;j<vertices;j++)",
			"      cout<<graph[i][j]<<\" \";",
			"    cout<<endl;",
			"  }",
			"",
			"  floyd_warshal(graph);",
			"",
			"  return 0;",
			"}"
		],
		"description": ""
	},
	"BELLMAN": {
		"prefix": "bellman",
		"body": [
			"#include<bits/stdc++.h>",
			"using namespace std;",
			"",
			"void bellman_ford(vector<vector<int>> graph, int source_vertex){",
			"  int vertices_number=graph.size();",
			"",
			"  vector<int> distance(vertices_number, INT_MAX);",
			"  distance[source_vertex-1]=0;",
			"",
			"  // RELAXATION",
			"  for(int k=1;k<vertices_number;k++)",
			"    for(int i=0;i<vertices_number;i++)",
			"      for(int j=0;j<vertices_number;j++)",
			"        if(graph[i][j]!=INT_MAX && distance[j]>distance[i]+graph[i][j])",
			"          distance[j]=distance[i]+graph[i][j];",
			"",
			"  // CHECKING NEGATIVE CYCLE",
			"  bool has_negative_cycle = false;",
			"  for(int i=0;i<vertices_number;i++){",
			"    for(int j=0;j<vertices_number;j++){",
			"      if(graph[i][j]!=INT_MAX && distance[j]>distance[i]+graph[i][j]){",
			"        distance[j]=distance[i]+graph[i][j];",
			"        has_negative_cycle=true;",
			"      }",
			"    }",
			"    if(has_negative_cycle)break;",
			"  }",
			"",
			"  cout<<endl;",
			"",
			"  // DISPLAYING SHORTEST PATH FROM SOURCE VERTEX",
			"  if(has_negative_cycle)cout<<\"The Graph Contain Negative Cycle\"<<endl;",
			"  else{",
			"    cout<<\"Shortest Path From Source Vertex:\"<<endl;",
			"    for(int i=0;i<vertices_number;i++){",
			"      cout<<\"Vertex \"<<i+1<<\": \";",
			"      (distance[i]==INT_MAX)?cout<<\"INT_MAX\"<<endl:cout<<distance[i]<<endl;",
			"    }",
			"  }",
			"",
			"",
			"}",
			"",
			"",
			"int main(){",
			"  int vertices, edges;",
			"",
			"  cout<<\"Enter Number of Vertices and Edges: \";",
			"  cin>>vertices>>edges;",
			"",
			"  // INITIALIZING LOOP NODE 0 AND OTHER INFINITY",
			"  vector<vector<int>> graph;",
			"  for(int i=0;i<vertices;i++){",
			"    vector<int> v;",
			"    for(int j=0;j<vertices;j++)v.push_back(INT_MAX);",
			"",
			"    graph.push_back(v);",
			"    graph[i][i]=0;",
			"  }",
			"",
			"  // GETTING INPUT",
			"  for(int i=0;i<edges;i++){",
			"    int from, to, weight;",
			"    cout<<\"Enter \"<<i+1<<\"th Edges and Their Weights: \";",
			"    cin>>from>>to>>weight;",
			"    graph[from-1][to-1]=weight;",
			"  }",
			"",
			"  int source_vertex;",
			"  cout<<\"Enter Source Vertex: \";",
			"  cin>>source_vertex;",
			"",
			"  // DISPLAYING GIVEN GRAPH",
			"  cout<<endl<<\"Given Graph:\"<<endl;",
			"  for(int i=0;i<vertices;i++){",
			"    for(int j=0;j<vertices;j++)",
			"     (graph[i][j]==INT_MAX)?cout<<\"I\"<<\" \":cout<<graph[i][j]<<\" \";",
			"    cout<<endl;",
			"  }",
			"",
			"  bellman_ford(graph, source_vertex);",
			"",
			"  return 0;",
			"}"
		],
		"description": ""
	},
	"ACTIVITY SELECTION": {
		"prefix": "activity_selection",
		"body": [
			"#include<bits/stdc++.h>",
			"using namespace std;",
			"",
			"bool compare(pair<int, int> a, pair<int, int> b){",
			"    return a.second < b.second;",
			"}",
			"",
			"void activity_selection(vector<pair<int, int>> pairs){",
			"  ",
			"  // SORTING BASED ON ENDING TIME OF THE SEMINARS",
			"  sort(pairs.begin(), pairs.end(), compare);",
			"",
			"  // STORING SELECTED SEMINAR",
			"  vector<pair<int, int>> selected_seminars;",
			"",
			"  // SELECTING FIRST SEMINAR",
			"  selected_seminars.push_back(pairs[0]);",
			"",
			"  // SELECTION CALCULATION FOR OTHER SEMINAR",
			"  for(int i=1;i<pairs.size();i++){",
			"    if(pairs[i].first>=selected_seminars.back().second){",
			"      //vector_name.back() METHOD IS USED TO ACCESS THE LAST ELEMENT OF THE VECTOR",
			"      selected_seminars.push_back(pairs[i]);",
			"    }",
			"  }",
			"",
			"  cout<<endl;",
			"",
			"  // DISPLAYING SELECTED SEMINARS",
			"  cout << \"Selected Seminars:\" << endl;",
			"  for (auto seminar : selected_seminars) {",
			"      cout << \"Start Time: \" << seminar.first << \", End Time: \" << seminar.second << endl;",
			"  }",
			"}",
			"",
			"int main(){",
			"  vector<pair<int, int>> pairs;",
			"  int number_of_seminer, start, end;",
			"  cout<<\"Enter Number of Seminar: \";",
			"  cin>>number_of_seminer;",
			"",
			"  for(int i=0;i<number_of_seminer;i++){",
			"    cout<<i+1<<\"th Seminar Start and End Time: \";",
			"    cin>>start>>end;",
			"    pairs.push_back(make_pair(start,end));",
			"  }",
			"",
			"  activity_selection(pairs);",
			"",
			"  return 0;",
			"}"
		],
		"description": ""
	},
	"Fractional Knapsack": {
		"prefix": "fractional",
		"body": [
			"#include<bits/stdc++.h>",
			"using namespace std;",
			"",
			"bool compare(pair<int, int> a, pair<int, int> b){",
			"  // USE MULTIPLICATION TO AVOID PRECISION LOSS",
			"  return a.first*b.second>a.second*b.first;",
			"",
			"  // return (double)a.first/a.second>(double)b.first/b.second;",
			"}",
			"",
			"void fractional_knapsack(vector<pair<int, int>> pairs, int knapsack_size){",
			"  ",
			"  // SORTING BASED ON PROFIT/WEIGHT",
			"  sort(pairs.begin(), pairs.end(), compare);",
			"",
			"  double profit=0.0;",
			"  int current_weight=0;",
			"",
			"  cout<<endl;  ",
			"  ",
			"  for(int i=0;i<pairs.size();i++){",
			"    if(current_weight+pairs[i].second<=knapsack_size){",
			"      // CALCULATING FOR INTEGER",
			"      current_weight+=pairs[i].second;",
			"      profit+=pairs[i].first;",
			"      cout<<\"Selected Profit: \"<<pairs[i].first<<\" Weight: \"<<pairs[i].second<<endl;",
			"    }else{",
			"      // CALCULATING FOR FRACTION",
			"      double remaining_weight=knapsack_size-current_weight;",
			"      if(remaining_weight!=0){",
			"        profit+=((double)pairs[i].first/pairs[i].second)*remaining_weight;",
			"        cout<<\"Selected Profit: \"<<(pairs[i].first/pairs[i].second)*remaining_weight<<\" Weight: \"<<remaining_weight<<endl;",
			"      }",
			"      break;",
			"    }",
			"  }",
			"",
			"  cout<<\"Total Profit: \"<<profit<<endl;",
			"}",
			"",
			"int main(){",
			"  int knapsack_size, number_of_item, profit, weight;",
			"  vector<pair<int, int>> pairs;",
			"",
			"  cout<<\"Enter Number Of Item: \";",
			"  cin>>number_of_item;",
			"",
			"  for(int i=0;i<number_of_item;i++){",
			"    cout<<\"Enter \"<<i+1<<\"th Item Profit and Weight: \";",
			"    cin>>profit>>weight;",
			"    pairs.push_back(make_pair(profit, weight));",
			"  }",
			"",
			"  cout<<\"Enter Knapsack Size: \";",
			"  cin>>knapsack_size;",
			"",
			"  fractional_knapsack(pairs, knapsack_size);",
			"  return 0;",
			"}"
		],
		"description": ""
	},
	"Job Scheduling": {
		"prefix": "job_scheduling",
		"body": [
			"#include<bits/stdc++.h>",
			"using namespace std;",
			"",
			"bool compare(pair<int, int> a, pair<int, int> b){",
			"    return a.first > b.first;",
			"}",
			"",
			"void job_scheduling(vector<pair<int, int>> pairs){",
			"",
			"  // SORTING BASED ON PROFIT",
			"  sort(pairs.begin(), pairs.end(), compare);",
			"",
			"  // MAXIMUM DEADLINE",
			"  int mx=pairs[0].second;",
			"  for(int i=1;i<pairs.size();i++)mx=max(mx, pairs[i].second);",
			"",
			"  // SELECTING JOB",
			"  vector<pair<pair<int, int>, bool>> seleected;",
			"  for(int i=0;i<=mx;i++)seleected.push_back(make_pair(make_pair(-1, -1), false));",
			"",
			"  for(int i=0;i<pairs.size();i++){",
			"    int target_slot=pairs[i].second;",
			"      while(target_slot>0 && seleected[target_slot].second)target_slot--;",
			"      if(target_slot>0)seleected[target_slot]=make_pair(make_pair(pairs[i].first, pairs[i].second), true);",
			"  }",
			"",
			"  cout<<endl;",
			"",
			"  // DISPLAYING SELECTED JOB AND CALCULATING TOTAL PROFIT",
			"  cout<<\"Selected Profit And Deadline:\"<<endl;",
			"  int total_profit=0;",
			"  for(int i=1;i<=mx;i++){",
			"    if(seleected[i].second){",
			"      pair<int, int> item = seleected[i].first;",
			"      cout<<item.first<<\" \"<<item.second<<endl;",
			"      total_profit+=item.first;",
			"    }",
			"  }",
			"  cout<<endl<<\"Total Profit: \"<<total_profit<<endl;",
			"}",
			"",
			"int main(){",
			"  int number_of_item, profit, deadline;",
			"  vector<pair<int, int>> pairs;",
			"",
			"  cout<<\"Enter Number Of Item: \";",
			"  cin>>number_of_item;",
			"",
			"  for(int i=0;i<number_of_item;i++){",
			"    cout<<\"Enter \"<<i+1<<\"th Item Profit and Deadline: \";",
			"    cin>>profit>>deadline;",
			"    pairs.push_back(make_pair(profit, deadline));",
			"  }",
			"",
			"  job_scheduling(pairs);",
			"",
			"  return 0;",
			"}"
		],
		"description": ""
	}

}
